# Bash-скрипты, часть 8: язык обработки данных awk

#### Особенности вызова awk
```bash
awk options program file
```

| Ключ | Описание |
| --- | --- |
|-F fs | позволяет указать символ-разделитель для полей в записи. |
|-f file | указывает имя файла, из которого нужно прочесть awk-скрипт. |
|-v var=value | позволяет объявить переменную и задать её значение по умолчанию, которое будет использовать awk. |
|-mf N | задаёт максимальное число полей для обработки в файле данных. |
|-mr N | задаёт максимальный размер записи в файле данных. |
|-W keyword | позволяет задать режим совместимости или уровень выдачи предупреждений awk. |

#### Чтение awk-скриптов из командной строки
```bash
awk '{print "Welcome to awk command tutorial"}'
```

#### Позиционные переменные, хранящие данные полей
| Переменная | Описание |
| --- | --- |
| $0 | представляет всю строку текста (запись). |
| $1 | первое поле. |
| $2 | второе поле. |
| $n | n-ное поле. |
```bash
echo first second | awk '{print $1}'
```
Указать разделитель
```bash
awk -F: '{print $1}' /etc/passwd
echo "first\tsecond\tthird extended" | awk -F\t '{print $3}'

```

#### Использование нескольких команд
```bash
echo "My name is Tom" | awk '{$4="Adam"; print $0}'
```

#### Чтение скрипта awk из файла
Содержимое файла testfile
```
{
  text = " has a  home directory at "
  print $1 text $6
}
```
```bash
awk -F: -f testfile /etc/passwd
```

#### Выполнение команд до начала обработки данных и после 
```bash
awk 'BEGIN {print "Hello World!"}'
```

```bash
echo "My name is Tom" | awk 'BEGIN {print "The File Contents:"} {print $0} END {print "End of File"}'
```

пример скрипта awk в файле myscript
```bash
BEGIN {
  print "The latest list of users and shells"
  print " UserName \t HomePath"
  print "-------- \t -------"
  FS=":"
}
{
  print $1 " \t " $6
}
END {
  print "The end"
}
```

```bash
grep -v '^#' /etc/passwd | awk -f myscript
```

#### Встроенные переменные: настройка процесса обработки данных
| Переменная | Описание |
| --- | --- |
| FIELDWIDTHS | разделённый пробелами список чисел, определяющий точную ширину каждого поля данных с учётом разделителей полей. |
| FS | уже знакомая вам переменная, позволяющая задавать символ-разделитель полей. |
| RS | переменная, которая позволяет задавать символ-разделитель записей. |
| OFS | разделитель полей на выводе awk-скрипта. |
| ORS | разделитель записей на выводе awk-скрипта. |

```bash
grep -v '^#' /etc/passwd | awk 'BEGIN{FS=":"; OFS=" - "} {print $1,$6,$7}'
```

файл addresses
```
Person Name
123 High Street
(222) 466-1234

Another person
487 High Street
(523) 643-8754
```

```bash
awk 'BEGIN{FS="\n"; RS=""} {print $1,$3}' addresses
```

#### Встроенные переменные: сведения о данных и об окружении
| Переменная | Описание |
| --- | --- |
| ARGC | количество аргументов командной строки. |
| ARGV | массив с аргументами командной строки. |
| ARGIND | индекс текущего обрабатываемого файла в массиве ARGV. |
| ENVIRON | ассоциативный массив с переменными окружения и их значениями. |
| ERRNO | код системной ошибки, которая может возникнуть при чтении или закрытии входных файлов. |
| FILENAME | имя входного файла с данными. |
| FNR | номер текущей записи в файле данных. |
| IGNORECASE | если эта переменная установлена в ненулевое значение, при обработке игнорируется регистр символов. |
| NF | общее число полей данных в текущей записи. |
| NR | общее число обработанных записей. |

```bash
awk 'BEGIN{print ARGC,ARGV[1]}' myfile
```

```bash
awk '
BEGIN{
  print ENVIRON["HOME"]
  print ENVIRON["PATH"]
}'
```

```bash
echo | awk -v home=$HOME '{print "My home is " home}'
```

Переменная NF позволяет обращаться к последнему полю данных в записи, не зная его точной позиции:
```bash
grep -v '^#' /etc/passwd | awk 'BEGIN{FS=":"; OFS=" - "} {print $1,$NF}'
```

#### Пользовательские переменные
```bash
awk '
BEGIN{
  test="This is a test"
  print test
}'
```

#### Условный оператор
```bash
echo -e "10\n15\n6\n33\n45" | awk '{if ($1 > 20) print $1}'

echo -e "10\n15\n6\n33\n45" | awk '{
  if ($1 > 20) {
    x = $1 * 2
    print x
  }
}'

echo -e "10\n15\n6\n33\n45" | awk '{if ($1 > 20) print $1 * 2; else print $1 / 2}'
```

#### Цикл while
```bash
echo -e "124 127 130\n112 142 135\n175 158 245" | awk '{
  total = 0
  i = 1
  while (i < 4) {
    total += $i
    if (i == 2)
    break
    i++
  }
  avg = total / 2
  print "The average of the first two elements is:",avg
}'
```

#### Цикл for
```bash
echo -e "124 127 130\n112 142 135\n175 158 245" | awk '{
  total = 0
  for (i = 1; i < 4; i++) {
    total += $i
  }
  avg = total / 3
  print "Average:",avg
}'
```

#### Форматированный вывод данных
```
%[modifier]control-letter
```
| Плейсхолдер | Описание |
| --- | --- |
| c | воспринимает переданное ему число как код ASCII-символа и выводит этот символ. |
| d | выводит десятичное целое число. |
| i | то же самое, что и d. |
| e | выводит число в экспоненциальной форме. |
| f | выводит число с плавающей запятой. |
| g | выводит число либо в экспоненциальной записи, либо в формате с плавающей запятой, в зависимости от того, как получается короче. |
| o | выводит восьмеричное представление числа. |
| s | выводит текстовую строку. |

```bash
awk 'BEGIN{
  x = 100 * 100
  printf "The result is: %e\n", x
}'
```

#### Встроенные математические функции
| Функции | Описание |
| --- | --- |
| cos(x) | косинус x (x выражено в радианах). |
| sin(x) | синус x. |
| exp(x) | экспоненциальная функция. |
| int(x) | возвращает целую часть аргумента. |
| log(x) | натуральный логарифм. |
| rand() | возвращает случайное число с плавающей запятой в диапазоне 0 - 1. |
| sqrt(x) | квадратный корень из x. |

```bash
awk 'BEGIN{x=exp(5); print x}'
```

#### Строковые функции
```bash
awk 'BEGIN{x = "likegeeks"; print toupper(x)}'
```

#### Пользовательские функции
```bash
grep -v '^#' /etc/passwd | awk '
  function myprint() {
    printf "The user %s has home path at %s\n", $1,$6
  }
  BEGIN{FS=":"}
  {
    myprint()
  }'
```


#### Дополнительно
```bash
echo -e "12 21\n-12 -21" | awk '$1 > 0 {print $2}' # вывести второе поле только если первое > 0
echo -e "first 1\nsecond 2\third 3" | awk '/se/ {print $1}' # обработать строки соответствующие регекспу
```
